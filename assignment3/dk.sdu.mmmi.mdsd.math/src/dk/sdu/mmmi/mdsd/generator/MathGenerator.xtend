/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		result.displayPanel
		
		for(e : resource.allContents.toIterable.filter(MathExp)) {
			fsa.generateFile(
				e.name.toString() + ".java",compile(e)
			)
		}
		
	}
	
	
	private def compile(MathExp mathexp) {
		'''
		package match_expression;
		
		public class «mathexp.name» {
			«FOR exp : mathexp.variables» 
			public int «exp.name»;
			«ENDFOR»
	
		
			public void compute() {
				«FOR exp : mathexp.variables» 
				«exp.name» = «exp.computeExpressionString»;
				«ENDFOR»
			}
		}
		'''
	}
		
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static compute(MathExp math) {
		variables = new HashMap()
		for(varBinding: math.variables)
			varBinding.computeExpression()
		variables
	}
	
	def static dispatch String computeExpressionString(VarBinding binding) {
		binding.expression.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(MathNumber exp) {
		exp.value.toString
	}

	def static dispatch String computeExpressionString(Plus exp) {
		exp.left.computeExpressionString +' + '+ exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Minus exp) {
		exp.left.computeExpressionString + ' - ' + exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Mult exp) {
		exp.left.computeExpressionString +' * '+ exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Div exp) {
		exp.left.computeExpressionString + ' / '+ exp.right.computeExpressionString
	}

	def static dispatch String computeExpressionString(LetBinding exp) {
		exp.body.computeExpressionString
	}
	
	
	def static String computeBindingString(LetBinding binding){
		binding.binding.computeExpressionString
	}
	
	
	

	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	
	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}
	
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExpression
	}
	
}
